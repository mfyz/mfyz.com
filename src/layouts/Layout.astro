---
import { ViewTransitions } from "astro:transitions";
import Header from "@components/Header.astro";
import Footer from "@components/Footer.astro";
import "@styles/global.css";
import { SITE } from "@/consts";

interface Props {
  title?: string;
  description?: string;
  size?: "small" | "large";
  noContentWrapperClass?: boolean;
  lang?: string;
  frontmatter?: Record<string, any>;
}

// Get properties from Astro.props and handle frontmatter data
const pageFrontmatter = Astro.props.frontmatter || {};

// Merge frontmatter and props, giving props priority
const { title, description, size, noContentWrapperClass, lang } = {
  ...pageFrontmatter,
  ...Astro.props,
};

const pathname = Astro.url.pathname;
const {
  website,
  author,
  description: defaultDescription,
  ogImage,
  title: defaultTitle,
} = SITE;

// Generate canonical URL
const canonicalURL = new URL(pathname, website).toString();

// Extract title from frontmatter, props, or use default
const rawTitle = pageFrontmatter.title || title || defaultTitle;
const pageDescription = description || defaultDescription;

// Format title consistently: "Page Title - mfyz.com" for pages with custom titles
const formattedTitle =
  rawTitle !== defaultTitle ? rawTitle : `${SITE.title} - ${SITE.description}`;

// Set language based on frontmatter
const pageLang = lang || "en";

const ogImageBasedOnPath =
  pathname === "/"
    ? ogImage
    : `${pathname}${pathname.endsWith("/") ? `` : `/`}og.png`;
---

<!doctype html>
<html lang={pageLang}>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="theme-color"
      content="#f5f5f4"
      media="(prefers-color-scheme: light)"
    />
    <meta
      name="theme-color"
      content="#1f2937"
      media="(prefers-color-scheme: dark)"
    />

    <!-- General Meta Tags -->
    <title>{formattedTitle}</title>
    <meta name="title" content={formattedTitle} />
    <meta name="description" content={pageDescription} />
    <meta name="author" content={author} />
    <link rel="sitemap" href="/sitemap-index.xml" />
    <link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="200x200" />

    <!-- RSS Feed Discovery -->
    {
      pageLang === "tr" ? (
        <link
          rel="alternate"
          type="application/rss+xml"
          title="mfyz (Türkçe)"
          href="/tr/rss.xml"
        />
      ) : (
        <link
          rel="alternate"
          type="application/rss+xml"
          title="mfyz"
          href="/rss.xml"
        />
      )
    }

    <!-- Canonical URL -->
    <link rel="canonical" href={canonicalURL} />

    <!-- Open Graph / Facebook -->
    <meta property="og:title" content={formattedTitle} />
    <meta property="og:description" content={pageDescription} />
    <meta property="og:url" content={canonicalURL} />
    <meta property="og:image" content={website + ogImageBasedOnPath} />
    <meta property="og:image:height" content="600" />
    <meta property="og:image:width" content="800" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:type" content="website" />

    <!-- Twitter -->
    <meta property="twitter:title" content={formattedTitle} />
    <meta property="twitter:description" content={pageDescription} />
    <meta property="twitter:image" content={website + ogImageBasedOnPath} />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:image:width" content="800" />
    <meta name="twitter:image:height" content="600" />

    {
      import.meta.env.PUBLIC_VERCEL_ENV === "production" && (
        <>
          <script
            async
            src="https://www.googletagmanager.com/gtag/js?id=G-L5KRCLT50D"
          />
          <Fragment
            set:html={`
            <script is:inline>
              const isAdmin = document.cookie.includes('mfyz_admin=');
              if (!isAdmin) {
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
                gtag('config', 'G-L5KRCLT50D');
              }
            </script>
            `}
          />
        </>
      )
    }

    <ViewTransitions />
  </head>

  <body
    class="grid min-h-screen grid-rows-[1fr_auto] bg-white text-text dark:bg-gray-900 dark:text-gray-200"
    style="scrollbar-gutter: stable"
  >
    <Header size={size} lang={pageLang} />
    <main
      class={`container ${size === "small" ? "mt-16 pt-8 px-1 md:px-3 lg:px-4" : "mt-24"} pb-4`}
      style="scrollbar-gutter: stable; max-width: 100vw;"
    >
      <div
        class={`${noContentWrapperClass ? "" : "main-content-wrapper"} mx-auto max-w-${size === "small" ? "3xl" : "5xl"}`}
      >
        <slot />
      </div>
    </main>

    <!-- Code block enhancement script -->
    <script is:inline>
      /**
       * Code Blocks Enhancement Script
       *
       * This script attaches copy and word wrap toggle buttons to code blocks in the document.
       */

      console.log("Code blocks script loaded");

      // Initialize immediately and also on page transition with Astro
      function initCodeBlocks() {
        console.log("Initializing code block buttons");
        const copyButtonLabel = "Copy";
        const wrapButtonLabel = "Wrap";
        const codeBlocks = Array.from(document.querySelectorAll("pre"));

        console.log(`Found ${codeBlocks.length} code blocks to enhance`);

        for (const codeBlock of codeBlocks) {
          // Skip if this code block already has buttons
          if (codeBlock.parentNode?.classList?.contains("code-block-wrapper")) {
            continue;
          }

          // Create wrapper for relative positioning
          const wrapper = document.createElement("div");
          wrapper.style.position = "relative";
          wrapper.className = "code-block-wrapper";

          // Create button group container
          const buttonGroup = document.createElement("div");
          buttonGroup.className =
            "code-buttons-group absolute right-3 -top-3 flex rounded overflow-hidden";

          // Create word wrap toggle button (first in the group) - icon only
          const wrapButton = document.createElement("button");
          wrapButton.className =
            "wrap-code bg-gray-500 dark:bg-gray-700 py-1 px-2 text-xs text-white font-medium rounded-l flex items-center justify-center";
          wrapButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4"><path d="M3 6h18"/><path d="M3 12h10"/><path d="M3 18h18"/><path d="M17 12v6"/><path d="M17 12l-4 4"/><path d="M17 12l4 4"/></svg>`;
          wrapButton.setAttribute("aria-label", wrapButtonLabel);
          wrapButton.setAttribute("aria-pressed", "false");
          wrapButton.setAttribute("title", "Toggle word wrap");

          // Create divider between buttons
          const divider = document.createElement("div");
          divider.className = "border-r border-gray-400 dark:border-gray-600";

          // Create copy button (second in the group) - icon with text
          const copyButton = document.createElement("button");
          copyButton.className =
            "copy-code bg-gray-500 dark:bg-gray-700 py-1 px-2 text-xs text-white font-medium rounded-r flex items-center";
          copyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-3 h-3 mr-0.5"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>${copyButtonLabel}`;
          copyButton.setAttribute(
            "aria-label",
            `${copyButtonLabel} code to clipboard`
          );
          copyButton.setAttribute(
            "title",
            `${copyButtonLabel} code to clipboard`
          );

          // Make sure we have the code element
          const code = codeBlock.querySelector("code");
          if (!code) continue; // Skip if no code element found

          // Get the original code content
          const clone = code.cloneNode(true);
          const originalCode = clone.innerText;

          // Toggle word wrap on click
          wrapButton.addEventListener("click", () => {
            const isPressed =
              wrapButton.getAttribute("aria-pressed") === "true";
            const newPressedState = !isPressed;
            wrapButton.setAttribute("aria-pressed", newPressedState.toString());

            if (newPressedState) {
              code.classList.add("whitespace-pre-wrap");
              wrapButton.classList.add("active-button");
              wrapButton.classList.add("bg-blue-600", "dark:bg-blue-800");
              wrapButton.classList.remove("bg-gray-500", "dark:bg-gray-700");
            } else {
              code.classList.remove("whitespace-pre-wrap");
              wrapButton.classList.remove("active-button");
              wrapButton.classList.remove("bg-blue-600", "dark:bg-blue-800");
              wrapButton.classList.add("bg-gray-500", "dark:bg-gray-700");
            }
          });

          // Copy to clipboard on click
          copyButton.addEventListener("click", () => {
            navigator.clipboard.writeText(originalCode);
            const originalContent = copyButton.innerHTML;
            copyButton.innerText = "Copied!";
            copyButton.setAttribute("disabled", "");
            copyButton.classList.add("copied");

            setTimeout(() => {
              copyButton.innerHTML = originalContent;
              copyButton.removeAttribute("disabled");
              copyButton.classList.remove("copied");
            }, 2000);
          });

          // Add buttons to button group
          buttonGroup.appendChild(wrapButton);
          buttonGroup.appendChild(divider);
          buttonGroup.appendChild(copyButton);

          // Add button group to wrapper
          wrapper.appendChild(buttonGroup);

          // Replace code block with wrapper containing code block and buttons
          codeBlock.parentNode.insertBefore(wrapper, codeBlock);
          wrapper.appendChild(codeBlock);
        }
      }

      // Initialize on first load
      document.addEventListener("DOMContentLoaded", initCodeBlocks);

      // Re-initialize on Astro page transitions
      document.addEventListener("astro:page-load", initCodeBlocks);

      // Fallback - try to initialize after a short delay
      setTimeout(initCodeBlocks, 500);
    </script>

    <!-- Mermaid diagrams enhancement script -->
    <script is:inline>
      /**
       * Mermaid Diagrams Enhancement Script
       *
       * Automatically detects code blocks with 'mermaid' language and converts them to diagrams
       */

      console.log("Mermaid enhancement script loaded");

      // Initialize Mermaid diagrams
      async function initMermaidDiagrams() {
        console.log("Scanning for Mermaid code blocks");

        // Debug: Log all code blocks and their classes
        const allCodeBlocks = Array.from(document.querySelectorAll("pre code"));
        console.log(`Found ${allCodeBlocks.length} total code blocks`);
        allCodeBlocks.forEach((block, i) => {
          console.log(
            `Code block ${i}: className="${block.className}", textContent preview="${block.textContent.substring(0, 50).trim()}"`
          );
        });

        // Try multiple selectors to find mermaid blocks
        const selectors = [
          'pre[data-language="mermaid"] code',
          'pre code[class*="language-mermaid"]',
          'pre code[class*="mermaid"]',
          'pre code[data-language="mermaid"]',
          'pre[class*="language-mermaid"] code',
          'pre[class*="mermaid"] code',
        ];

        let mermaidBlocks = [];
        for (const selector of selectors) {
          const blocks = Array.from(document.querySelectorAll(selector));
          if (blocks.length > 0) {
            console.log(
              `Found ${blocks.length} mermaid blocks with selector: ${selector}`
            );
            mermaidBlocks = blocks;
            break;
          }
        }

        // Fallback: look for code blocks that contain mermaid syntax
        if (mermaidBlocks.length === 0) {
          console.log("No mermaid blocks found by class, checking content...");
          const potentialMermaidBlocks = allCodeBlocks.filter(block => {
            const text = block.textContent.trim().toLowerCase();
            return (
              text.startsWith("graph ") ||
              text.startsWith("flowchart ") ||
              text.startsWith("sequencediagram") ||
              text.startsWith("pie ") ||
              text.includes("participant ")
            );
          });

          if (potentialMermaidBlocks.length > 0) {
            console.log(
              `Found ${potentialMermaidBlocks.length} potential mermaid blocks by content analysis`
            );
            mermaidBlocks = potentialMermaidBlocks;
          }
        }

        if (mermaidBlocks.length === 0) {
          console.log("No Mermaid diagrams found");
          return;
        }

        console.log(
          `Found ${mermaidBlocks.length} Mermaid diagram(s) to render`
        );

        try {
          // Dynamically load Mermaid from CDN
          if (!window.mermaid) {
            console.log("Loading Mermaid from CDN...");

            // Create and load the script
            const script = document.createElement("script");
            script.src =
              "https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js";
            script.type = "module";

            await new Promise((resolve, reject) => {
              script.onload = resolve;
              script.onerror = reject;
              document.head.appendChild(script);
            });

            console.log("Mermaid library loaded successfully");
          }

          // Initialize Mermaid with theme support
          const isDarkMode =
            document.documentElement.classList.contains("dark");

          mermaid.initialize({
            startOnLoad: false,
            theme: isDarkMode ? "dark" : "default",
            themeVariables: {
              primaryColor: "#8b5cf6",
              primaryBorderColor: "#7c3aed",
              secondaryColor: "#fbbf24",
              tertiaryColor: "#fff",
              background: isDarkMode ? "#1f2937" : "#ffffff",
              mainBkg: isDarkMode ? "#1f2937" : "#ffffff",
              secondBkg: isDarkMode ? "#374151" : "#f3f4f6",
              tertiaryBkg: isDarkMode ? "#4b5563" : "#e5e7eb",
              primaryTextColor: isDarkMode ? "#f3f4f6" : "#1f2937",
              lineColor: isDarkMode ? "#6b7280" : "#d1d5db",
              textColor: isDarkMode ? "#f3f4f6" : "#1f2937",
              mainContrastColor: isDarkMode ? "#f3f4f6" : "#1f2937",
              darkMode: isDarkMode,
            },
            flowchart: {
              htmlLabels: true,
              curve: "basis",
            },
            sequence: {
              diagramMarginX: 50,
              diagramMarginY: 30,
              actorMargin: 50,
              width: 150,
              height: 65,
              boxMargin: 10,
              boxTextMargin: 5,
              noteMargin: 10,
              messageMargin: 35,
            },
          });

          // Process each Mermaid code block
          for (let i = 0; i < mermaidBlocks.length; i++) {
            const codeElement = mermaidBlocks[i];
            const preElement = codeElement.parentElement;
            let chartDefinition = codeElement.textContent.trim();

            if (!chartDefinition) continue;

            try {
              console.log(
                `Rendering Mermaid diagram ${i + 1}/${mermaidBlocks.length}`
              );

              // Store reference to button group for restoration if needed
              const codeBlockWrapper = preElement.parentElement;
              let buttonGroup = null;
              if (
                codeBlockWrapper &&
                codeBlockWrapper.classList.contains("code-block-wrapper")
              ) {
                buttonGroup = codeBlockWrapper.querySelector(
                  ".code-buttons-group"
                );
              }

              // Parse styling attributes from multiple sources
              let customWidth = "";
              let customHeight = "";
              let customAlign = "";
              let showBorder = false;
              let compactMode = false;

              // Auto-detect pie charts for compact mode
              const isPieChart = chartDefinition
                .trim()
                .toLowerCase()
                .includes("pie title");

              // Method 1: Check for attributes in data attributes
              if (preElement.dataset.width) {
                customWidth =
                  preElement.dataset.width.includes("%") ||
                  preElement.dataset.width.includes("px")
                    ? preElement.dataset.width
                    : `${preElement.dataset.width}px`;
              }
              if (preElement.dataset.height) {
                customHeight =
                  preElement.dataset.height.includes("%") ||
                  preElement.dataset.height.includes("px")
                    ? preElement.dataset.height
                    : `${preElement.dataset.height}px`;
              }
              if (preElement.dataset.align) {
                customAlign = preElement.dataset.align;
              }
              if (preElement.dataset.border !== undefined) {
                showBorder = true;
              }
              if (preElement.dataset.compact !== undefined) {
                compactMode = true;
              }

              // Method 2: Parse styling from HTML comment before the pre element
              let previousNode = preElement.previousSibling;
              while (
                previousNode &&
                previousNode.nodeType === 3 &&
                !previousNode.textContent.trim()
              ) {
                // Skip whitespace text nodes
                previousNode = previousNode.previousSibling;
              }

              if (previousNode && previousNode.nodeType === 8) {
                // Comment node
                const comment = previousNode.textContent.trim();
                const widthMatch = comment.match(/width=["']([^"']+)["']/);
                const heightMatch = comment.match(/height=["']([^"']+)["']/);
                const alignMatch = comment.match(/align=["']([^"']+)["']/);
                const borderMatch = comment.match(/border/);

                if (widthMatch && !customWidth) {
                  customWidth =
                    widthMatch[1].includes("%") || widthMatch[1].includes("px")
                      ? widthMatch[1]
                      : `${widthMatch[1]}px`;
                }
                if (heightMatch && !customHeight) {
                  customHeight =
                    heightMatch[1].includes("%") ||
                    heightMatch[1].includes("px")
                      ? heightMatch[1]
                      : `${heightMatch[1]}px`;
                }
                if (alignMatch && !customAlign) {
                  customAlign = alignMatch[1];
                }
                if (borderMatch && !showBorder) {
                  showBorder = true;
                }
              }

              // Method 3: Parse styling from first line of code if it starts with %% (mermaid comment)
              const lines = chartDefinition.split("\n");
              if (lines[0].trim().startsWith("%%")) {
                const firstLine = lines[0].trim();
                const widthMatch = firstLine.match(/width=(\w+)/);
                const heightMatch = firstLine.match(/height=(\w+)/);
                const alignMatch = firstLine.match(/align=(\w+)/);
                const centerMatch = firstLine.match(/center/);
                const borderMatch = firstLine.match(/border/);

                if (widthMatch && !customWidth) {
                  customWidth =
                    widthMatch[1].includes("%") || widthMatch[1].includes("px")
                      ? widthMatch[1]
                      : `${widthMatch[1]}px`;
                }
                if (heightMatch && !customHeight) {
                  customHeight =
                    heightMatch[1].includes("%") ||
                    heightMatch[1].includes("px")
                      ? heightMatch[1]
                      : `${heightMatch[1]}px`;
                }
                if (alignMatch && !customAlign) {
                  customAlign = alignMatch[1];
                }
                if (centerMatch && !customAlign) {
                  customAlign = "center";
                }
                if (borderMatch && !showBorder) {
                  showBorder = true;
                }

                // Remove the styling comment from chart definition
                const chartWithoutSizing = lines.slice(1).join("\n").trim();
                if (chartWithoutSizing) {
                  chartDefinition = chartWithoutSizing;
                }
              }

              // Create container for the diagram
              const diagramContainer = document.createElement("div");
              diagramContainer.className =
                "mermaid-container my-8 w-full overflow-x-auto";

              // Apply custom width if specified
              if (customWidth) {
                diagramContainer.style.width = customWidth;
                diagramContainer.style.maxWidth = customWidth;
              }

              // Apply alignment if specified
              if (customAlign === "center") {
                // Only center if we have a custom width, otherwise it doesn't make sense
                if (customWidth) {
                  diagramContainer.style.margin = "2rem auto";
                  diagramContainer.style.display = "block";
                  diagramContainer.classList.remove("w-full");
                }
              } else if (customAlign === "left") {
                if (customWidth) {
                  diagramContainer.style.marginLeft = "0";
                  diagramContainer.style.marginRight = "auto";
                  diagramContainer.classList.remove("w-full");
                }
              } else if (customAlign === "right") {
                if (customWidth) {
                  diagramContainer.style.marginLeft = "auto";
                  diagramContainer.style.marginRight = "0";
                  diagramContainer.classList.remove("w-full");
                }
              }

              const diagramWrapper = document.createElement("div");
              let wrapperClasses = "mermaid-diagram rounded-lg min-h-[100px]";

              // Apply border and padding styling
              if (showBorder) {
                wrapperClasses +=
                  " border border-gray-200 bg-white shadow-sm dark:border-gray-700 dark:bg-gray-900 p-4";
              } else {
                wrapperClasses += " bg-transparent";
              }

              // Force left alignment for the content inside the wrapper
              if (!customAlign || (customAlign && !customWidth)) {
                wrapperClasses += " text-left";
              }

              diagramWrapper.className = wrapperClasses;

              // Apply custom height if specified
              if (customHeight) {
                diagramWrapper.style.height = customHeight;
                diagramWrapper.style.minHeight = customHeight;
              }

              // Generate unique ID for this diagram
              const uniqueId = `mermaid-diagram-${i}-${Date.now()}`;

              // Render the diagram first (before replacing the element)
              const { svg } = await mermaid.render(uniqueId, chartDefinition);

              // Only if rendering succeeds, replace the code block
              diagramWrapper.innerHTML = svg;
              diagramContainer.appendChild(diagramWrapper);
              preElement.parentNode.replaceChild(diagramContainer, preElement);

              // Hide copy/wrap buttons now that we've successfully replaced the element
              if (buttonGroup) {
                buttonGroup.style.display = "none";
              }

              // Make SVG responsive (unless custom height is specified)
              const svgElement = diagramWrapper.querySelector("svg");
              if (svgElement) {
                if (!customHeight) {
                  svgElement.removeAttribute("height");
                  svgElement.style.height = "auto";
                }
                if (!customWidth) {
                  svgElement.style.maxWidth = "100%";
                }

                // Apply custom dimensions directly to SVG if specified
                if (customWidth) {
                  svgElement.style.width = customWidth;
                  svgElement.style.maxWidth = customWidth; // Override Mermaid's max-width
                }
                if (customHeight) {
                  svgElement.style.height = customHeight;
                  svgElement.style.maxHeight = customHeight; // Override Mermaid's max-height
                }

                // Ensure left alignment when no explicit centering is requested
                if (!customAlign || (customAlign && !customWidth)) {
                  svgElement.style.display = "block";
                  svgElement.style.marginLeft = "0";
                  svgElement.style.marginRight = "auto";
                }

                // Apply compact mode for pie charts automatically
                if (isPieChart) {
                  // Scale up the pie chart content and crop the whitespace
                  svgElement.style.transform = "scale(1.8)";
                  svgElement.style.transformOrigin = "65% center";

                  // Adjust the container to hide overflow
                  const container = svgElement.parentElement;
                  if (container) {
                    container.style.overflow = "hidden";
                  }
                }
              }

              const styleInfo = [];
              if (customWidth || customHeight)
                styleInfo.push(
                  `${customWidth || "auto"} x ${customHeight || "auto"}`
                );
              if (customAlign) styleInfo.push(customAlign);
              if (showBorder) styleInfo.push("bordered");
              if (isPieChart) styleInfo.push("compact");

              console.log(
                `Successfully rendered Mermaid diagram ${i + 1}${styleInfo.length ? ` (${styleInfo.join(", ")})` : ""}`
              );
            } catch (error) {
              console.warn(
                `Mermaid rendering failed for diagram ${i + 1}, falling back to code block:`,
                error
              );

              // If we already replaced the element, we need to restore it
              // But since we moved the replacement logic after successful render,
              // the original code block should still be there

              // Don't replace anything - keep the original code block
              console.log(`Diagram ${i + 1} will remain as a code block`);
            }
          }
        } catch (error) {
          console.warn(
            "Failed to load Mermaid library, code blocks will remain as code blocks:",
            error
          );

          // Restore copy/wrap buttons for all mermaid code blocks since they'll stay as code blocks
          mermaidBlocks.forEach(codeElement => {
            const preElement = codeElement.parentElement;
            const codeBlockWrapper = preElement.parentElement;
            if (
              codeBlockWrapper &&
              codeBlockWrapper.classList.contains("code-block-wrapper")
            ) {
              const buttonGroup = codeBlockWrapper.querySelector(
                ".code-buttons-group"
              );
              if (buttonGroup && buttonGroup.style.display === "none") {
                buttonGroup.style.display = "";
              }
            }
          });

          console.log(
            "All Mermaid code blocks will remain as regular code blocks"
          );
        }
      }

      // Initialize on first load
      document.addEventListener("DOMContentLoaded", initMermaidDiagrams);

      // Re-initialize on Astro page transitions
      document.addEventListener("astro:page-load", initMermaidDiagrams);

      // Fallback - try to initialize after a short delay
      setTimeout(initMermaidDiagrams, 1000);
    </script>

    <Footer lang={pageLang} size={size} />
  </body>
</html>
