---
interface Heading {
  depth: number;
  slug: string;
  text: string;
}

interface Props {
  headings: Heading[];
}

const { headings } = Astro.props;

// Filter to h2/h3 only (h1 is the post title)
const tocHeadings = headings.filter(h => h.depth === 2 || h.depth === 3);

// Only render if 5+ headings
const shouldRender = tocHeadings.length >= 5;
---

{
  shouldRender && (
    <nav
      id="toc-sidebar"
      class="fixed z-40 hidden xl:block"
      aria-label="Table of Contents"
    >
      <div class="toc-inner max-h-[calc(100vh-8rem)] overflow-y-auto pr-2">
        <p class="mb-2 text-xs font-semibold uppercase tracking-wider text-gray-400 dark:text-gray-500">
          On this page
        </p>
        <ul class="space-y-1 border-l border-gray-200 dark:border-gray-700">
          {tocHeadings.map(heading => (
            <li>
              <a
                href={`#${heading.slug}`}
                class:list={[
                  "toc-link -ml-px block border-l-2 text-sm leading-6 transition-colors duration-150",
                  heading.depth === 3 ? "pl-8" : "pl-4",
                  "border-transparent text-gray-500 hover:border-gray-400 hover:text-gray-900 dark:text-gray-400 dark:hover:border-gray-500 dark:hover:text-gray-200",
                ]}
                data-slug={heading.slug}
              >
                {heading.text}
              </a>
            </li>
          ))}
        </ul>
      </div>
    </nav>
  )
}

<script>
  function initTOC() {
    const toc = document.getElementById("toc-sidebar");
    if (!toc) return;

    // Calculate where the content starts (below the hero)
    const mainContent = document.querySelector(".main-content-wrapper");
    if (!mainContent) return;

    const contentTopOffset =
      mainContent.getBoundingClientRect().top + window.scrollY;

    function positionTOC() {
      if (!mainContent) return;

      const rect = mainContent.getBoundingClientRect();
      const rightEdge = rect.right;
      const availableSpace = window.innerWidth - rightEdge;

      if (availableSpace < 200) {
        toc.style.display = "none";
        return;
      }

      toc.style.display = "block";
      toc.style.left = `${rightEdge + 24}px`;
      toc.style.width = `${Math.min(availableSpace - 48, 220)}px`;

      // If we haven't scrolled past the content start, position absolutely
      // Once scrolled past, switch to fixed positioning
      const scrollY = window.scrollY;
      if (scrollY < contentTopOffset - 96) {
        toc.style.position = "absolute";
        toc.style.top = `${contentTopOffset}px`;
      } else {
        toc.style.position = "fixed";
        toc.style.top = "6rem";
      }
    }

    positionTOC();
    window.addEventListener("resize", positionTOC);
    window.addEventListener("scroll", positionTOC, { passive: true });

    const links = toc.querySelectorAll(
      ".toc-link"
    ) as NodeListOf<HTMLAnchorElement>;
    const slugs = Array.from(links).map(l => l.dataset.slug!);

    requestAnimationFrame(() => {
      const headingElements = slugs
        .map(slug => document.getElementById(slug))
        .filter(Boolean) as HTMLElement[];

      if (headingElements.length === 0) return;

      let activeSlug = "";

      function setActive(slug: string) {
        if (slug === activeSlug) return;
        activeSlug = slug;
        links.forEach(link => {
          const isActive = link.dataset.slug === slug;
          link.classList.toggle("border-primary", isActive);
          link.classList.toggle("dark:border-primary-light", isActive);
          link.classList.toggle("text-gray-900", isActive);
          link.classList.toggle("dark:text-gray-100", isActive);
          link.classList.toggle("font-medium", isActive);
          link.classList.toggle("border-transparent", !isActive);
          link.classList.toggle("text-gray-500", !isActive);
          link.classList.toggle("dark:text-gray-400", !isActive);
        });
      }

      const observer = new IntersectionObserver(
        entries => {
          const visible = entries
            .filter(e => e.isIntersecting)
            .sort(
              (a, b) => a.boundingClientRect.top - b.boundingClientRect.top
            );

          if (visible.length > 0) {
            setActive(visible[0].target.id);
          }
        },
        {
          rootMargin: "-80px 0px -60% 0px",
          threshold: 0,
        }
      );

      headingElements.forEach(el => observer.observe(el));

      document.addEventListener(
        "astro:before-swap",
        () => {
          observer.disconnect();
          window.removeEventListener("resize", positionTOC);
          window.removeEventListener("scroll", positionTOC);
        },
        { once: true }
      );
    });
  }

  document.addEventListener("astro:page-load", initTOC);
</script>
